#+TITLE: =get_user_by_email= route of the =Guard= component
#+AUTHOR: Anirudh Reddy
#+DATE: [2017-07-6 Thu]
#+SETUPFILE: ../../../../org-templates/level-4.org
#+TAGS: boilerplate(b)
#+EXCLUDE_TAGS: boilerplate
#+OPTIONS: ^:nil

* Introduction  

This is the specification and implementation of the
=get_user_by_email= route of the =Guard= component.  
* Checks

 - TypeCheck :: Check whether the instruction consists of the command
                =get_user_by_email=, the =data= dictionary of =email=
                object of type Email and additionally contains a
                session object (and nothing else).  The typecheck may
                be implemented by consulting the [[../../../datatypes/instr/index.org][instruction datatype]]
                specification.


 - AuthCheck :: Check whether the role in the session is =admin= or
                =user=.  This is always true as the user can have
                either an =admin= or a =user= role

 - StateCheck :: Check whether the session in the instruction is
                 indeed an entity currently present in the entity
                 manager's session aggregate.

* Implemenbtation
** Imports and class =GetUser=
#+BEGIN_SRC python :tangle get_user_by_email.py
import traceback
from runtime.exceptions.app.exception import AppException
from runtime.utils.type_utils.type_utils import check_pred
from runtime.datatypes.cmd.cmd import Cmd
from runtime.objects.user.user import User
from runtime.objects.session.session import Session
from runtime.objects.role.role import Role
from runtime.datatypes.instr.get_user_by_email.get_user_by_email_instr import GetUserInstr

class GetUser:

#+END_SRC

** The type structure of the =get_user_by_email= route

The =get_user_by_email= route is a dictionary with 'cmd' equal to
=Cmd.get_user_by_email=, a 'data' which is again a dictionary with 
'email' which is instance of class =Email= and a 'session' 
that is an instance of =Session=.

** The =do= method
This method takes a component and instruction and simply
does all the checks.
#+BEGIN_SRC python :tangle get_user_by_email.py
    @staticmethod 
    def do(component, instr):
        print "get_user_by_email: %s" % instr

        GetUser.check_type(instr)
        GetUser.check_auth(component, instr)
        GetUser.check_state(component, instr)
        return instr

#+END_SRC
* Checks
** Type checks

Check if the the instruction is of the correct shape,
i.e. satisfies the predicate =GetUserInstr.is_inst=.

#+BEGIN_SRC python :tangle get_user_by_email.py
    @staticmethod
    def check_type(instr):
         check_pred(GetUserInstr.is_inst)(instr)
#+END_SRC

** Authorization check

      Check whether the role in the instruction's session is either
      =user= or =admin=.  (This will always be true since a session's
      role must either be equal to =Role.user= or an =Role.admin=.
      
      There is constraint that is to taken care of i.e, The email given in the 
      instruction should belong to atleast one of the users in the entity.

#+BEGIN_SRC python :tangle get_user_by_email.py
    @staticmethod
    def check_auth(obj, instr):
        email = instr['data']['email']
        email = email.get('val')
        userlist = obj.em.get_all(User)
        emails = []
        for i in range(len(userlist)):
            emails.append(userlist[i].get("email").get("val"))
        if email not in emails:
            raise AppException(op="get_user_by_email.check_auth",
                msg="No user found")
        return instr

#+END_SRC

** State check

This check passes if the session is already an entity
present in the entity manager.  Otherwise an exception
is raised.

    1. Retrieve the session from the instruction.
 
    2. Retrieve the entity manager from the component.
 
    3. Check if the session is present in the entity
       manager. 

    4. If the session is not present, then raise an
       exception.  The instruction's session must always be
       in the session aggregate managed by the entity manager.

#+BEGIN_SRC python :tangle get_user_by_email.py

    @staticmethod
    def check_state(component, instr):
        if not component.em.is_present(instr['session']):
            raise AppException(op="get_user_by_emailn.check_state",
                                   msg="session is not in the entity manager")
        else:
            return instr

#+END_SRC

* Packages
#+BEGIN_SRC python :eval no :tangle __init__.py
print "runtime.components.guard.get_user_by_email package"
#+END_SRC
