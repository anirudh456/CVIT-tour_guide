#+TITLE: =del_role= route of the =Guard= component
#+AUTHOR: Anirudh Reddy
#+DATE: [2017-06-27 Tue]
#+SETUPFILE: ../../../../org-templates/level-4.org
#+TAGS: boilerplate(b)
#+EXCLUDE_TAGS: boilerplate
#+OPTIONS: ^:nil

* Introduction  

This is the specification and implementation of the
=del_role= route of the =Guard= component.  
* Checks

 - TypeCheck :: Check whether the instruction consists of the command
                =del_role=, the =data= dictionary of =user= object of
                type User , =delrole= object of type Role and
                additionally contains a session object (and nothing
                else).  The typecheck may be implemented by consulting
                the [[../../../datatypes/instr/index.org][instruction datatype]] specification.


 - AuthCheck :: Check whether the role in the session is =admin=.
                Only admins are allowed to delete roles of a user.

 - StateCheck :: Check whether the session in the instruction is
                 indeed an entity currently present in the entity
                 manager's session aggregate.

Note that there is a unique constraint on the role field of 
the user to be deleted.The role to be deleted should be in the list 
of roles of the user and the number roles of the user in the roles list 
should be greater than 1 (>1). 
* Implemenbtation
** Imports and class =DelRole=
#+BEGIN_SRC python :tangle del_role.py
import traceback
from runtime.exceptions.app.exception import AppException
from runtime.utils.type_utils.type_utils import check_pred
from runtime.datatypes.cmd.cmd import Cmd
from runtime.objects.session.session import Session
from runtime.objects.role.role import Role
from runtime.datatypes.instr.del_role.del_role_instr import DelRoleInstr

class DelRole:

#+END_SRC

** The type structure of the =del_role= route

The =del_role= route is a dictionary with 'cmd' equal to
=Cmd.del_role=, a 'data' which is again a dictionary with 
'user' which is instance of class =User= and a 'session' 
that is an instance of =Session=.

** The =do= method
This method takes a component and instruction and simply
does all the checks.
#+BEGIN_SRC python :tangle del_role.py
    @staticmethod 
    def do(component, instr):
        print "del_role: %s" % instr

        DelRole.check_type(instr)
        DelRole.check_auth(component, instr)
        DelRole.check_state(component, instr)
        return instr

#+END_SRC
* Checks
** Type checks

Check if the the instruction is of the correct shape,
i.e. satisfies the predicate =DelRoleInstr.is_inst=.

#+BEGIN_SRC python :tangle del_role.py
    @staticmethod
    def check_type(instr):
         check_pred(DelRoleInstr.is_inst)(instr)
#+END_SRC

** Authorization check

The Authorization checks for the following two authorization
constraints:

   1. Only an =admin= may perform the =del_role= operation
 
   2. The role that is to be deleted should be present in the list of roles 
of the user and the the number of roles in the list of roles of the user
should be greater than 1.If not,an exception is to be raised.

*** Steps

    1. Retrieve the session from the instr
 
    2. Retrieve the user from the session

    3. Retrieve the role from the session

    4. If the role is not an admin role (=Role.admin=) then
       raise an exception.

    5. Get the roles of the user from the instruction's data key.

    6. If the number of roles in the list of roles of the user is not greater
       than 1, then raise an exception.

    7. Get the role from the instruction's delrole key.

    8. If the role to be deleted is not a role of that 
       user then raise an exception.


#+BEGIN_SRC python :tangle del_role.py
    @staticmethod
    def check_auth(obj, instr):
        session = instr['session']
        
        role = session.get("role")
        user = instr['data']['user']
        roles = user.get('roles')
        delrole = instr['data']['delrole']
        if role != Role.admin:
            raise AppException(op="del_role.check_auth", 
                msg="Only admin can delete a role")
        if not delrole in roles and len(roles) > 1 :
            raise AppException(op="del_role.check_auth",
                msg="cannot delete the role.")
        return instr
        

#+END_SRC

** State check

This check passes if the session is already an entity
present in the entity manager.  Otherwise an exception
is raised.

    1. Retrieve the session from the instruction.
 
    2. Retrieve the entity manager from the component.
 
    3. Check if the session is present in the entity
       manager. 

    4. If the session is not present, then raise an
       exception.  The instruction's session must always be
       in the session aggregate managed by the entity manager.

#+BEGIN_SRC python :tangle del_role.py

    @staticmethod
    def check_state(component, instr):
        if not component.em.is_present(instr['session']):
            raise AppException(op="del_role.check_state",
                                   msg="session is not in the entity manager")
        else:
            return instr

#+END_SRC

* Packages
#+BEGIN_SRC python :eval no :tangle __init__.py
print "runtime.components.guard.del_role package"
#+END_SRC
