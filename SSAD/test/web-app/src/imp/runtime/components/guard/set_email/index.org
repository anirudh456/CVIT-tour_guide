#+TITLE: =set_email= route of the =Guard= component
#+AUTHOR: VLEAD
#+DATE: [2017-06-29 Thu]
#+SETUPFILE: ../../../../org-templates/level-4.org
#+TAGS: boilerplate(b)
#+EXCLUDE_TAGS: boilerplate
#+OPTIONS: ^:nil

* Introduction  

This is the specification and implementation of the
=set_email= route of the =Guard= component.  

* Checks

 - TypeCheck :: Check whether the instruction consists of the command
                =set_email=, the =data= dictionary of =user= object of
                type User,the =setemail= dictionary of =email= object
                of type =Email= and additionally contains a session
                object (and nothing else).  The typecheck may be
                implemented by consulting the [[../../../datatypes/instr/index.org][instruction datatype]]
                specification.


 - AuthCheck :: Check whether the role in the session is =admin=.  If
                the role in the session is =user=,then check whether
                the user of the session and the user whose email to be
                set are the same.

 - StateCheck :: Check whether the session in the
      instruction is indeed an entity currently present in
      the entity manager's session aggregate.

Note that there is a unique constraint on the email field of the user
to be set. The email should not already belong to an existing user.

* Implementation
** Imports and class =SetEmail=
#+BEGIN_SRC python :tangle set_email.py
import traceback
from runtime.exceptions.app.exception import AppException
from runtime.utils.type_utils.type_utils import check_pred
from runtime.datatypes.cmd.cmd import Cmd
from runtime.objects.session.session import Session
from runtime.objects.role.role import Role
from runtime.objects.email.email import Email
from runtime.objects.user.user import User
from runtime.datatypes.instr.set_email.set_email_instr import SetEmailInstr

class SetEmail:

#+END_SRC

** The type structure of the =set_email= route

The =set_email= route is a dictionary with 'cmd' equal to
=Cmd.set_email=, a 'data' which is again a dictionary with 'user'
which is instance of class =User=, a 'setemail' which is a dictionary
with 'email' which is an instance of class =Email= and a 'session'
that is an instance of =Session=.

** The =do= method
This method takes a component and instruction and simply
does all the checks.
#+BEGIN_SRC python :tangle set_email.py
    @staticmethod 
    def do(component, instr):
        print "set_email: %s" % instr

        SetEmail.check_type(instr)
        SetEmail.check_auth(component, instr)
        SetEmail.check_state(component, instr)
        return instr

#+END_SRC
* Checks
** Type checks

Check if the the instruction is of the correct shape,
i.e. satisfies the predicate =SetEmailInstr.is_inst=.

#+BEGIN_SRC python :tangle set_email.py
    @staticmethod
    def check_type(instr):
         check_pred(SetEmailInstr.is_inst)(instr)
#+END_SRC

** Authorization check

This function checks if the user in the session of the instruction
has =admin= role .  If not,it checks whether the user in the session
and the user whose email is to be set is the same.If both are false,
it raises an exception.

    1. Retrieve the session from the instr
 
    2. Retrieve the user from the session

    3. Retrieve the role from the session

    4. If the role is not an admin role (=Role.admin=) then,

    5. Retrieve the user from data from the instr and check whether 
       the user in session is same as the user given in data.

    6. If both are false, then raise an exception

    7. The email that is to be set should not already be an email of the existing users.
       
    8. Otherwise return the instruction.

#+BEGIN_SRC python :tangle set_email.py
    @staticmethod
    def check_auth(component, instr):
        session = instr['session']
        user = session.get('user')
        role = session.get('role')
        setemail = instr['data']['setemail']
        setemail = setemail.get('val')
        setuser = instr['data']['user']
        emails = []
        userlist = component.em.get_all(User)
        for i in range(len(userlist)):
            emails.append(userlist[i].get("email").get("val"))
        if not setemail in emails:
            if role != Role.admin:
                if setuser != user:
                    raise AppException(op="set_email.check_auth",
                        msg="You cannot set the email to this user.")
                return instr
            return instr
        raise AppException(op="set_email.check_auth",
                        msg="This email cannot be used.")

#+END_SRC

** State check

This check passes if the session is already an entity
present in the entity manager.  Otherwise an exception
is raised.

    1. Retrieve the session from the instruction.
 
    2. Retrieve the entity manager from the component.
 
    3. Check if the session is present in the entity
       manager. 

    4. If the session is not present, then raise an
       exception.  The instruction's session must always be
       in the session aggregate managed by the entity manager.

#+BEGIN_SRC python :tangle set_email.py

    @staticmethod
    def check_state(component, instr):
        if not component.em.is_present(instr['session']):
            raise AppException(op="set_email.check_state",
                                   msg="session is not in the entity manager")
        else:
            return instr

#+END_SRC

* Package                                                       :boilerplate:
#+BEGIN_SRC python :eval no :tangle __init__.py
print "runtime.components.guard.set_email package"
#+END_SRC


